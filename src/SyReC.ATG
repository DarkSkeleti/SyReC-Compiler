// Set the name of your grammar here (and at the end of this grammar):
    import SymTable.SymTable;
    import java.util.Set;
    import SymTable.Obj;
    import SymTable.Mod;
    import CodeGen.Code;
    import CodeGen.SignalObject;
    import CodeGen.ExpressionObject;

COMPILER SyReC

// Add auxiliary methods and declaration here.



    private boolean IsIdentEql(){
        scanner.ResetPeek();
        return (la.kind == '$' && scanner.Peek().kind == _ident && scanner.Peek().kind == '=');
    }

    private boolean NumberTo(){
        scanner.ResetPeek();
        Token x = la;
        Token next = scanner.Peek();
        if(la.kind == _int) {
            return next.kind == _to;
        }
        if(la.kind == '#' && next.kind == _ident) {
            next = scanner.Peek();
            return next.kind == _to;
        }
        if(la.kind == '$' && next.kind == _ident) {
                    next = scanner.Peek();
                    return next.kind == _to;
        }
        if(la.kind == '(') {
            int i = 1;
            while (i > 0) {
                if(next.kind == '(') {
                    i++;
                }
                else if(next.kind == ')'){
                    i--;
                }
                next = scanner.Peek();
            }
            return next.kind == _to;
        }
        return false;
    }

    private boolean IsShift(){
        scanner.ResetPeek();
        Token next = scanner.Peek();
        if(!la.val.equals("(")) {
            return false;
        }
            int i = 1;
            while (i > 0) {
                if(next.val.equals("(")) {
                    i++;
                }
                else if(next.val.equals(")")){
                    i--;
                }
                else if(i == 1 && (next.kind == _shiftL || next.kind == _shiftR)){
                    return true;
                }
                next = scanner.Peek();
            }
            return false;
    }
    private static final Set<Integer> BinExp = Set.of(_plus, _minus, _xor, _lmul, _divide, _rem, _hmul, _bitAND, _bitOR, _AND, _OR, _less, _greater, _eql, _neql, _leql, _geql);
        boolean IsBinary(){
            scanner.ResetPeek();
            Token x = la;
            Token next = scanner.Peek();
            if(la.kind != '(') {
                return false;
            }
                int i = 1;
                while (i > 0) {
                    if(next.kind == '(') {
                        i++;
                    }
                    else if(next.kind == ')'){
                        i--;
                    }
                    else if(i == 1 && BinExp.contains(next.kind)){
                        return true;
                    }
                    next = scanner.Peek();
                }
                return false;
        }
        SymTable tab = new SymTable();
        Mod curMod;

        private String fileName = null;
        Code codegen = null;
        public void setName(String name){
            fileName = name;
            codegen = new Code(fileName);
        }



        private void Warning (String msg) { //add Warning as function to not need to specify line and col
        		errors.Warning(t.line, t.col, msg);
        	}
// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.

CHARACTERS
    letter = 'A'..'Z' + 'a'..'z'.
    digit = "0123456789".



TOKENS
    ident   =   ('_'|letter) {'_'|letter|digit}.
    int     =   digit {digit}.
    to      =   "to". //for LookAhead in ForStatement
    shiftR  =   ">>". //for LookAhead  in Expression (shift vs Binary)
    shiftL  =   "<<".
    plus    =   '+'. // to differentiate between Expression and number
    minus   =   '-'.
    xor     =   '^'.
    lmul    =   '*'.
    divide  =   '/'.
    rem     =   '%'.
    hmul    =   "*>".
    bitAND  =   "&%".
    bitOR   =   "||".
    AND     =   '&'.
    OR      =   '|'.
    less    =   '<'.
    greater =   '>'.
    eql     =   '='.
    neql    =   "!=".
    leql    =   "<=".
    geql    =   ">=".



PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)
    activateLine        =   "§lineOn".                  (.codegen.lineAware = true;.)
    deactivateLine      =   "§lineOff".                 (.codegen.lineAware = false;.)
    activateCost        =   "§costOn".                  (.codegen.costAware = true;.)
    deactivateCost      =   "§costOff".                 (.codegen.costAware = false;.)

COMMENTS FROM "//" TO "\n"
IGNORE "\r" + "\n" + "\t"


PRODUCTIONS
    number<out int number>              =   (.number = 0;.)(int         (.number = Integer.parseInt(t.val);.)
                                            |'#'ident                   (.number = curMod.getLocal(t.val).width;.)
                                            |'$'ident   //placeholder for loops
                                            |('('number<out int firstNumber> ('+'|'-'|'*'|'/')
                                                                        (.char calcToggle = t.val.charAt(0);.)
                                            number<out int secondNumber>      (.switch(calcToggle) {
                                                                case '+':
                                                                    number = firstNumber+secondNumber;
                                                                    break;
                                                                case '-':
                                                                    number = firstNumber-secondNumber;
                                                                    break;
                                                                case '*':
                                                                   number = firstNumber*secondNumber;
                                                                    break;
                                                                case '/':
                                                                    number = firstNumber/secondNumber;
                                                                    break;
                                                                default:
                                                                    number = 0;
                                                                    break;
                                                        }.)
                                            ')')).
    //number is a Production and not a Token because it is recursive

    //Program and Modules
    SyReC               =   Module {Module}.

    Module              =   "module" ident                                      (.//add module to SymTable
                                                        if(!tab.addModule(t.val)) {
                                                            SemErr("Module "+t.val+" is already defined");
                                                        }
                                                        curMod = tab.getModule(t.val);
                                                                                .)
                            '(' ParameterList ')' {SignalList}                  (.codegen.createModule(curMod);
                                                                                ExpressionObject ifExp = new ExpressionObject(1); //generate alwaysTrue if
                                                                                .)
                            StatementList<ifExp>               (.codegen.endModule(curMod);.).
    ParameterList       =   Parameter {',' Parameter}.
    Parameter           =                               (.Obj.Kind kind = null;.)
                            ("in"                       (.kind = Obj.Kind.In;.)
                            |"out"                      (.kind = Obj.Kind.Out;.)
                            |"inout"                    (.kind = Obj.Kind.Inout;.)
                            ) SignalDeclaration<kind>.
    SignalList          =                               (.Obj.Kind kind = null;.)
                            ("wire"                     (.kind = Obj.Kind.Wire;.)
                            |"state"                    (.kind = Obj.Kind.State;.)
                            ) SignalDeclaration<kind> {',' SignalDeclaration<kind>}.


    SignalDeclaration<Obj.Kind kind>   =   ident        (.String ident = t.val;
                                                        int width = 1;.)
                                           {'['int']'}
                                           ['('int      (.width = Integer.parseInt(t.val);.)
                                           ')']
                                           (.curMod.addObj(new Obj(kind, ident, width));.).

    //Statements
    StatementList<ExpressionObject ifExp>       =   Statement<ifExp> {';' Statement<ifExp>}.
    Statement<ExpressionObject ifExp>           =   CallStatement | ForStatement<ifExp> | IfStatement<ifExp> | UnaryStatement<ifExp> | SkipStatement | Signal<out SignalObject firstSig, ifExp> (SwapStatement<firstSig, ifExp> | AssignStatement<firstSig, ifExp>).
    CallStatement       =   ("call"|"uncall") ident     (.Mod calledMod = tab.getModule(t.val);
                                                        if(calledMod == null) {
                                                            Warning("Module "+t.val+"was not defined before this point");
                                                        }
                                                        .)
                            '(' ident                   (.int parCount = 1;.)
                            {',' ident                  (.parCount++;.)
                            } ')'                       (.if(calledMod != null && parCount != calledMod.getParameterCount()) {
                                                            SemErr("Module "+calledMod.name+"needs "+calledMod.getParameterCount()+" parameters");
                                                            //Errorcheck for correct width needed
                                                        }.)
                            .
    ForStatement<ExpressionObject ifExp>        =   "for" [IF(IsIdentEql() || NumberTo()) [IF (IsIdentEql())'$' ident '='] number<out int start> "to"] number<out int stop> ["step" ['-'] number<out int stepsize>] StatementList<ifExp> "rof".


    IfStatement<ExpressionObject outsideIfExp>         =   "if" Expression<out ExpressionObject ifExp, outsideIfExp>                (.codegen.resetExpressionNoLine(ifExp);
                                                                                                                                    ExpressionObject combinedIf = new ExpressionObject(0);
                                                                                                                                    if(ifExp.isNumber && (ifExp.number != 0 && ifExp.number != 1)) {
                                                                                                                                        SemErr("if Expression is a number but neither 0 or 1");
                                                                                                                                    }
                                                                                                                                    else if(!ifExp.isNumber && ifExp.getWidth() != 1) {
                                                                                                                                        SemErr("if Expression is a Signal with a Width of "+ifExp.getWidth()+" instead of 1");
                                                                                                                                        ifExp = new ExpressionObject(0);
                                                                                                                                    }
                                                                                                                                    else if(!ifExp.isNumber && !outsideIfExp.isNumber) {
                                                                                                                                        //both are signals so we dont want to combine them with the logical & function
                                                                                                                                        combinedIf = new ExpressionObject(ifExp.signals.get(0));
                                                                                                                                        combinedIf.addSignals(outsideIfExp.signals);
                                                                                                                                    }
                                                                                                                                    else {
                                                                                                                                        //if neither or only one is a number we can just use the & function
                                                                                                                                        combinedIf = codegen.logicalAnd(outsideIfExp, ifExp);
                                                                                                                                    }
                                                                                                                                    .)
                                                        "then" StatementList<combinedIf>                                            (.if(ifExp.isNumber) {
                                                                                                                                        if(ifExp.number == 0) {
                                                                                                                                            ifExp = new ExpressionObject(1);
                                                                                                                                        }
                                                                                                                                        else {
                                                                                                                                            ifExp = new ExpressionObject(0);
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    else if(!(outsideIfExp.isNumber && outsideIfExp.number == 0)) {
                                                                                                                                        codegen.not(ifExp.signals.get(0), new ExpressionObject(1)); //invert if line
                                                                                                                                    }
                                                                                                                                    if (!ifExp.isNumber && !outsideIfExp.isNumber){
                                                                                                                                        //both are signals so we dont want to combine them with the logical & function
                                                                                                                                        combinedIf = new ExpressionObject(ifExp.signals.get(0));
                                                                                                                                        combinedIf.addSignals(outsideIfExp.signals);
                                                                                                                                    }
                                                                                                                                    else {
                                                                                                                                        //if neither or only one is a number we can just use the & function
                                                                                                                                        combinedIf = codegen.logicalAnd(outsideIfExp, ifExp);
                                                                                                                                    }
                                                                                                                                    .)
                                                        "else" StatementList<combinedIf>                                            (.if(!ifExp.isNumber && !(outsideIfExp.isNumber && outsideIfExp.number == 0)) { //we only need to invert back if its a line
                                                                                                                                        //no inversion if outsideIf is always false
                                                                                                                                        codegen.not(ifExp.signals.get(0), new ExpressionObject(1)); //invert if line
                                                                                                                                    }
                                                                                                                                    .)
                                                        "fi" Expression<out ExpressionObject fiExp, ifExp>                          (.if(!ifExp.isNumber && !(outsideIfExp.isNumber && outsideIfExp.number == 0) && ifExp.resetStart != -1) {
                                                                                                                                        //if the ifExpression is on a line we can reset the line
                                                                                                                                        //no reset if the outside is always false
                                                                                                                                        codegen.xorAssign(ifExp.signals.get(0), fiExp, new ExpressionObject(1));
                                                                                                                                        codegen.resetLine(ifExp.getLineName(0));
                                                                                                                                    }
                                                                                                                                    .)
                                                        .


    AssignStatement<SignalObject firstSignal, ExpressionObject ifExp>       =   ('^'|'+'|'-')                               (.String assignToggle = t.val;.)
                                                    '=' Expression<out ExpressionObject exp, ifExp>        (.boolean cantAssign = false;
                                                                                                    for(String line : firstSignal.getLines()) {
                                                                                                        if(exp.containsSignal(line)) {
                                                                                                      	    cantAssign = true;
                                                                                                      		break;
                                                                                                        }
                                                                                                    }
                                                                                                    if(cantAssign) {
                                                                                                        SemErr("Signal is contained in the Expression of the assign Statement");
                                                                                                    }
                                                                                                    else if(!exp.isNumber && exp.getWidth() != firstSignal.getWidth()) {
                                                                                                        SemErr("Signal Width is not equal");
                                                                                                    }
                                                                                                    else if(exp.isNumber && firstSignal.getWidth() < Math.ceil(Math.log(exp.number)/Math.log(2))) {
                                                                                                        SemErr(exp.number+" doesnt fit into the Signal Width");
                                                                                                    }
                                                                                                    else {
                                                                                                        switch(assignToggle) {
                                                                                                            case "^":
                                                                                                                codegen.xorAssign(firstSignal, exp, ifExp);
                                                                                                                codegen.resetExpression(exp);
                                                                                                                break;
                                                                                                            case "+":
                                                                                                                //TODO +assign
                                                                                                                break;
                                                                                                            default:
                                                                                                                //TODO -assign
                                                                                                                break;
                                                                                                        }
                                                                                                    }.)
                                                    .

    UnaryStatement<ExpressionObject ifExp>      =   ('~'|"++"|"--")             (.String calcToggle = t.val;.)
                                                '=' Signal<out SignalObject sig, ifExp>
                                                        (.switch(calcToggle) {
                                                            case "~":
                                                                codegen.not(sig, ifExp);
                                                                break;
                                                            case "++":
                                                                codegen.plusplus(sig, ifExp);
                                                                break;
                                                            default:
                                                                codegen.minusminus(sig, ifExp);
                                                                break;
                                                        }.)
                                                .

    SwapStatement<SignalObject firstSig, ExpressionObject ifExp>       =   "<=>" Signal<out SignalObject secondSig, ifExp>
                                                        (. if(firstSig.getWidth() != secondSig.getWidth() ){
                                                            SemErr("Signal Width is not equal");
                                                        }
                                                        else {
                                                            codegen.swap(firstSig, secondSig, ifExp);
                                                        }.).
    SkipStatement       =   "skip".
    //placeholder, needs to be updated to allow arrays and width
    Signal<out SignalObject sig, ExpressionObject ifExp>              =   ident         (.String ident = t.val;
                                                            if(!curMod.isDefined(ident)) {
                                                                SemErr("Signal "+ident+" is not defined");
                                                            }
                                                            Obj curSignal = curMod.getLocal(ident);
                                                            int startWidth = -1;
                                                            int endWidth = -1;
                                                            .)
                            {'[' Expression<out ExpressionObject exp, ifExp> ']'}
                            ['.' number<out int lowerBound> (.if(lowerBound >= curSignal.width || lowerBound < 0) {
                                                                SemErr("Signal out of bounds: "+lowerBound);
                                                            }
                                                            startWidth = lowerBound;
                                                            endWidth = lowerBound; //so far both are equal
                                                            .)
                            [':' number<out int uperBound>  (.if(uperBound >= curSignal.width || uperBound < 0) {
                                                                SemErr("Signal out of bounds: "+uperBound);
                                                            }
                                                            endWidth = uperBound;.)
                            ]]                              (.if(startWidth == -1) {
                                                                startWidth = 0;
                                                                endWidth = curSignal.width -1;
                                                            }
                                                            sig = new SignalObject (curSignal, startWidth, endWidth);.)
                            .

    //Expressions
    Expression<out ExpressionObject exp, ExpressionObject ifExp>                                                    (.exp = new ExpressionObject(0);.)
                        = Signal<out SignalObject sig, ifExp>                                      (.exp = new ExpressionObject(sig);.)
                        | IF (IsShift()) ShiftExpression<out ExpressionObject shiftExp, ifExp>     (.exp = shiftExp;.)
                        | IF (IsBinary())BinaryExpression<out ExpressionObject binExp, ifExp>      (.exp = binExp;.)
                        | UnaryExpression<out ExpressionObject unExp, ifExp>                       (.exp = unExp;.)
                        | number<out int number>                                            (.exp = new ExpressionObject(number);.)
                        .


    BinaryExpression<out ExpressionObject binExp, ExpressionObject ifExp>                                           (.binExp = new ExpressionObject(0);.)
                                                    =   '(' Expression<out ExpressionObject firstExp, ifExp> ('+'|'-'|'^'|'*'|'/'|'%'|"*>"|"&&"|"||"|'&'|'|'|'<'|'>'|'='|"!="|"<="|">=") Expression<out ExpressionObject secondExp, ifExp> ')'.


    UnaryExpression<out ExpressionObject unExp, ExpressionObject ifExp>     =                                               (.boolean bitwise = false;
                                                                                                    unExp = new ExpressionObject(0);.)
                                                    ('!'|'~'                                        (.bitwise = true;.)
                                                    ) Expression<out ExpressionObject exp, ifExp>          (.if(!bitwise) {
                                                                                                        if(exp.isNumber) {
                                                                                                            if(exp.number != 0) {
                                                                                                                unExp = new ExpressionObject(0);
                                                                                                            }
                                                                                                            else if(exp.number == 0) {
                                                                                                                unExp = new ExpressionObject(1);
                                                                                                            }
                                                                                                            else {
                                                                                                                SemErr("Logical Not on a number that is not 0 or 1");
                                                                                                            }
                                                                                                        }
                                                                                                        else {
                                                                                                            if(exp.getWidth() == 1) {
                                                                                                                if (!ifExp.isNumber || ifExp.number != 0) {
                                                                                                                    unExp = codegen.notExp(exp);
                                                                                                                }
                                                                                                                else {
                                                                                                                    unExp = exp; //if the ifExp is neither a signal nor a boolean 1 we can skip the Expression because it wont be used
                                                                                                                }
                                                                                                            }
                                                                                                            else {
                                                                                                                SemErr("Logical Not on a Busline or an Expression that is not a boolean");
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    else {
                                                                                                        if (!ifExp.isNumber || ifExp.number != 0) {
                                                                                                            unExp = codegen.notExp(exp);
                                                                                                        }
                                                                                                        else {
                                                                                                            unExp = exp; //if the ifExp is neither a signal nor a boolean 1 we can skip the Expression because it wont be used
                                                                                                        }
                                                                                                    }.)
                                                    .


    ShiftExpression<out ExpressionObject shiftExp, ExpressionObject ifExp>  =   '(' Expression<out ExpressionObject exp, ifExp>    (.boolean isLeft = false;.)
                                                  (shiftL                                           (.isLeft = true;.)
                                                  |shiftR
                                                  ) number<out int number> ')'                      (.if(isLeft && (!ifExp.isNumber || ifExp.number != 0)) {
                                                                                                        shiftExp = codegen.leftShift(exp, number);
                                                                                                    }
                                                                                                    else if(!isLeft && (!ifExp.isNumber || ifExp.number != 0)){
                                                                                                        shiftExp = codegen.rightShift(exp, number);
                                                                                                    }
                                                                                                    else {
                                                                                                        shiftExp = exp; //if the ifExp is neither a signal nor a boolean 1 we can skip the Expression because it wont be used
                                                                                                    }.).




// End of your compiler specification, make sure the name here matches
// the grammar name at the start of this grammar.
END SyReC.