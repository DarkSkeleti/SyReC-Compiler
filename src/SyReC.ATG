// Set the name of your grammar here (and at the end of this grammar):
    import SymTable.SymTable;
    import java.util.Set;
    import SymTable.Obj;
    import SymTable.Mod;
    import CodeGen.Code;
    import CodeGen.SignalObject;

COMPILER SyReC

// Add auxiliary methods and declaration here.



    private boolean IsIdentEql(){
        scanner.ResetPeek();
        return (la.kind == '$' && scanner.Peek().kind == _ident && scanner.Peek().kind == '=');
    }

    private boolean NumberTo(){
        scanner.ResetPeek();
        Token x = la;
        Token next = scanner.Peek();
        if(la.kind == _int) {
            return next.kind == _to;
        }
        if(la.kind == '#' && next.kind == _ident) {
            next = scanner.Peek();
            return next.kind == _to;
        }
        if(la.kind == '$' && next.kind == _ident) {
                    next = scanner.Peek();
                    return next.kind == _to;
        }
        if(la.kind == '(') {
            int i = 1;
            while (i > 0) {
                if(next.kind == '(') {
                    i++;
                }
                else if(next.kind == ')'){
                    i--;
                }
                next = scanner.Peek();
            }
            return next.kind == _to;
        }
        return false;
    }

    private boolean IsShift(){
        scanner.ResetPeek();
        Token x = la;
        Token next = scanner.Peek();
        if(la.kind != '(') {
            return false;
        }
            int i = 1;
            while (i > 0) {
                if(next.kind == '(') {
                    i++;
                }
                else if(next.kind == ')'){
                    i--;
                }
                else if(i == 1 && (next.kind == _shiftL || next.kind == _shiftR)){
                    return true;
                }
                next = scanner.Peek();
            }
            return false;
    }
    private static final Set<Integer> BinExp = Set.of(_plus, _minus, _xor, _lmul, _divide, _rem, _hmul, _bitAND, _bitOR, _AND, _OR, _less, _greater, _eql, _neql, _leql, _geql);
        boolean IsBinary(){
            scanner.ResetPeek();
            Token x = la;
            Token next = scanner.Peek();
            if(la.kind != '(') {
                return false;
            }
                int i = 1;
                while (i > 0) {
                    if(next.kind == '(') {
                        i++;
                    }
                    else if(next.kind == ')'){
                        i--;
                    }
                    else if(i == 1 && BinExp.contains(next.kind)){
                        return true;
                    }
                    next = scanner.Peek();
                }
                return false;
        }
        SymTable tab = new SymTable();
        Mod curMod;

        private String fileName = null;
        Code codegen = null;
        public void setName(String name){
            fileName = name;
            codegen = new Code(fileName);
        }



        private void Warning (String msg) { //add Warning as function to not need to specify line and col
        		errors.Warning(t.line, t.col, msg);
        	}
// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.

CHARACTERS
    letter = 'A'..'Z' + 'a'..'z'.
    digit = "0123456789".



TOKENS
    ident   =   ('_'|letter) {'_'|letter|digit}.
    int     =   digit {digit}.
    to      =   "to". //for LookAhead in ForStatement
    shiftR  =   ">>". //for LookAhead  in Expression (shift vs Binary)
    shiftL  =   "<<".
    plus    =   '+'. // to differentiate between Expression and number
    minus   =   '-'.
    xor     =   '^'.
    lmul    =   '*'.
    divide  =   '/'.
    rem     =   '%'.
    hmul    =   "*>".
    bitAND  =   "&%".
    bitOR   =   "||".
    AND     =   '&'.
    OR      =   '|'.
    less    =   '<'.
    greater =   '>'.
    eql     =   '='.
    neql    =   "!=".
    leql    =   "<=".
    geql    =   ">=".



PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


COMMENTS FROM "--" TO "\n"
IGNORE "\r" + "\n" + "\t"


PRODUCTIONS
    number<out int number>              =   (.number = 0;.)(int         (.number = Integer.parseInt(t.val);.)
                                            |'#'ident   (.number = curMod.getLocal(t.val).width;.)
                                            |'$'ident   //placeholder for loops
                                            |('('number<out int firstNumber> (.char calcToggle = '0';.)
                                            ('+'        (.calcToggle = '+';.)
                                            |'-'        (.calcToggle = '-';.)
                                            |'*'        (.calcToggle = '*';.)
                                            |'/'       (.calcToggle = '/';.)
                                            ) number<out int secondNumber>      (.switch(calcToggle) {
                                                                case '+':
                                                                    number = firstNumber+secondNumber;
                                                                    break;
                                                                case '-':
                                                                    number = firstNumber-secondNumber;
                                                                    break;
                                                                case '*':
                                                                   number = firstNumber*secondNumber;
                                                                    break;
                                                                case '/':
                                                                    number = firstNumber/secondNumber;
                                                                    break;
                                                                default:
                                                                    number = 0;
                                                                    break;
                                                        }.)
                                            ')')).
    //number is a Production and not a Token because it is recursive

    //Program and Modules
    SyReC               =   Module {Module}.

    Module              =   "module" ident              (.//add module to SymTable
                                                        if(!tab.addModule(t.val)) {
                                                            SemErr("Module "+t.val+" is already defined");
                                                        }
                                                        curMod = tab.getModule(t.val);
                                                        .)
                            '(' ParameterList ')' {SignalList} (.codegen.createModule(curMod);.)
                            StatementList               (.codegen.endModule(curMod);.).
    ParameterList       =   Parameter {',' Parameter}.
    Parameter           =                               (.Obj.Kind kind = null;.)
                            ("in"                       (.kind = Obj.Kind.In;.)
                            |"out"                      (.kind = Obj.Kind.Out;.)
                            |"inout"                    (.kind = Obj.Kind.Inout;.)
                            ) SignalDeclaration<kind>.
    SignalList          =                               (.Obj.Kind kind = null;.)
                            ("wire"                     (.kind = Obj.Kind.Wire;.)
                            |"state"                    (.kind = Obj.Kind.State;.)
                            ) SignalDeclaration<kind> {',' SignalDeclaration<kind>}.


    SignalDeclaration<Obj.Kind kind>   =   ident        (.String ident = t.val;
                                                        int width = 1;.)
                                           {'['int']'}
                                           ['('int      (.width = Integer.parseInt(t.val);.)
                                           ')']
                                           (.curMod.addObj(new Obj(kind, ident, width));.).

    //Statements
    StatementList       =   Statement {';' Statement}.
    Statement           =   CallStatement | ForStatement | IfStatement | UnaryStatement | SkipStatement | Signal<out SignalObject firstSig> (SwapStatement<firstSig> | AssignStatement<firstSig>).
    CallStatement       =   ("call"|"uncall") ident     (.Mod calledMod = tab.getModule(t.val);
                                                        if(calledMod == null) {
                                                            Warning("Module "+t.val+"was not defined before this point");
                                                        }
                                                        .)
                            '(' ident                   (.int parCount = 1;.)
                            {',' ident                  (.parCount++;.)
                            } ')'                       (.if(calledMod != null && parCount != calledMod.getParameterCount()) {
                                                            SemErr("Module "+calledMod.name+"needs "+calledMod.getParameterCount()+" parameters");
                                                        }.)
                            .
    ForStatement        =   "for" [IF(IsIdentEql() || NumberTo()) [IF (IsIdentEql())'$' ident '='] number<out int start> "to"] number<out int stop> ["step" ['-'] number<out int stepsize>] StatementList "rof".
    IfStatement         =   "if" Expression "then" StatementList "else" StatementList "fi" Expression.
    AssignStatement<SignalObject firstSignal>     =   ('^'|'+'|'-') '=' Signal<out SignalObject secondSig>.
    UnaryStatement      =   ('~'|"++"|"--") '=' Signal<out SignalObject sig>.
    SwapStatement<SignalObject firstSig>       =   "<=>" Signal<out SignalObject secondSig> (.codegen.swap(firstSig, secondSig);.).
    SkipStatement       =   "skip".
    //placeholder, needs to be updated to allow arrays and width
    Signal<out SignalObject sig>              =   ident         (.String ident = t.val;
                                                            if(!curMod.isDefined(ident)) {
                                                                SemErr("Signal "+ident+" is not defined");
                                                            }
                                                            Obj curSignal = curMod.getLocal(ident);
                                                            sig = new SignalObject (curSignal);.)
                            {'[' Expression ']'}
                            ['.' number<out int lowerBound> (.if(lowerBound > curSignal.width) {
                                                                SemErr("Signal out of bounds: "+lowerBound);
                                                            }
                                                            sig.startWidth = lowerBound;.)
                            [':' number<out int uperBound>  (.if(uperBound > curSignal.width) {
                                                                SemErr("Signal out of bounds: "+uperBound);
                                                            }
                                                            sig.endWidth = uperBound;.)
                            ]].

    //Expressions
    Expression          =   Signal<out SignalObject sig> | IF (IsShift()) ShiftExpression | IF (IsBinary())BinaryExpression | UnaryExpression | number<out int number>.
    BinaryExpression    =   '(' Expression ('+'|'-'|'^'|'*'|'/'|'%'|"*>"|"&&"|"||"|'&'|'|'|'<'|'>'|'='|"!="|"<="|">=") Expression ')'.
    UnaryExpression     =   ('!'|'~') Expression.
    ShiftExpression     =   '(' Expression (shiftL|shiftR) number<out int number> ')'.




// End of your compiler specification, make sure the name here matches
// the grammar name at the start of this grammar.
END SyReC.