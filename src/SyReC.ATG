// Set the name of your grammar here (and at the end of this grammar):
    import SymTable.SymTable;
    import java.util.Set;
    import SymTable.Obj;
    import SymTable.Mod;
    import CodeGen.Code;

COMPILER SyReC

// Add auxiliary methods and declaration here.



    private boolean IsIdentEql(){
        scanner.ResetPeek();
        return (la.kind == '$' && scanner.Peek().kind == _ident && scanner.Peek().kind == '=');
    }

    private boolean NumberTo(){
        scanner.ResetPeek();
        Token x = la;
        Token next = scanner.Peek();
        if(la.kind == _int) {
            return next.kind == _to;
        }
        if(la.kind == '#' && next.kind == _ident) {
            next = scanner.Peek();
            return next.kind == _to;
        }
        if(la.kind == '$' && next.kind == _ident) {
                    next = scanner.Peek();
                    return next.kind == _to;
        }
        if(la.kind == '(') {
            int i = 1;
            while (i > 0) {
                if(next.kind == '(') {
                    i++;
                }
                else if(next.kind == ')'){
                    i--;
                }
                next = scanner.Peek();
            }
            return next.kind == _to;
        }
        return false;
    }

    private boolean IsShift(){
        scanner.ResetPeek();
        Token x = la;
        Token next = scanner.Peek();
        if(la.kind != '(') {
            return false;
        }
            int i = 1;
            while (i > 0) {
                if(next.kind == '(') {
                    i++;
                }
                else if(next.kind == ')'){
                    i--;
                }
                else if(i == 1 && (next.kind == _shiftL || next.kind == _shiftR)){
                    return true;
                }
                next = scanner.Peek();
            }
            return false;
    }
    private static final Set<Integer> BinExp = Set.of(_plus, _minus, _xor, _lmul, _divide, _rem, _hmul, _bitAND, _bitOR, _AND, _OR, _less, _greater, _eql, _neql, _leql, _geql);
        boolean IsBinary(){
            scanner.ResetPeek();
            Token x = la;
            Token next = scanner.Peek();
            if(la.kind != '(') {
                return false;
            }
                int i = 1;
                while (i > 0) {
                    if(next.kind == '(') {
                        i++;
                    }
                    else if(next.kind == ')'){
                        i--;
                    }
                    else if(i == 1 && BinExp.contains(next.kind)){
                        return true;
                    }
                    next = scanner.Peek();
                }
                return false;
        }
        SymTable tab = new SymTable();
        Mod curMod;

        private String fileName = null;
        Code codegen = null;
        public void setName(String name){
            fileName = name;
            codegen = new Code(fileName);
        }



        private void Warning (String msg) { //add Warning as function to not need to specify line and col
        		errors.Warning(t.line, t.col, msg);
        	}
// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.

CHARACTERS
    letter = 'A'..'Z' + 'a'..'z'.
    digit = "0123456789".



TOKENS
    ident   =   ('_'|letter) {'_'|letter|digit}.
    int     =   digit {digit}.
    to      =   "to". //for LookAhead in ForStatement
    shiftR  =   ">>". //for LookAhead  in Expression (shift vs Binary)
    shiftL  =   "<<".
    plus    =   '+'. // to differentiate between Expression and number
    minus   =   '-'.
    xor     =   '^'.
    lmul    =   '*'.
    divide  =   '/'.
    rem     =   '%'.
    hmul    =   "*>".
    bitAND  =   "&%".
    bitOR   =   "||".
    AND     =   '&'.
    OR      =   '|'.
    less    =   '<'.
    greater =   '>'.
    eql     =   '='.
    neql    =   "!=".
    leql    =   "<=".
    geql    =   ">=".



PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


COMMENTS FROM "--" TO "\n"
IGNORE "\r" + "\n" + "\t"


PRODUCTIONS
    number              =   int|'#'ident|'$'ident|('('number('+'|'-'|'*'|'/')number')').
    //number is a Production and not a Token because it is recursive

    //Program and Modules
    SyReC               =   Module {Module}.

    Module              =   "module" ident              (.//add module to SymTable
                                                        if(!tab.addModule(t.val)) {
                                                            SemErr("Module "+t.val+" is already defined");
                                                        }
                                                        curMod = tab.getModule(t.val);
                                                        .)
                            '(' ParameterList ')' {SignalList} (.codegen.createModule(curMod);.)
                            StatementList               (.codegen.endModule(curMod);.).
    ParameterList       =   Parameter {',' Parameter}.
    Parameter           =                               (.Obj.Kind kind = null;.)
                            ("in"                       (.kind = Obj.Kind.In;.)
                            |"out"                      (.kind = Obj.Kind.Out;.)
                            |"inout"                    (.kind = Obj.Kind.Inout;.)
                            ) SignalDeclaration<kind>.
    SignalList          =                               (.Obj.Kind kind = null;.)
                            ("wire"                     (.kind = Obj.Kind.Wire;.)
                            |"state"                    (.kind = Obj.Kind.State;.)
                            ) SignalDeclaration<kind> {',' SignalDeclaration<kind>}.


    SignalDeclaration<Obj.Kind kind>   =   ident        (.curMod.addObj(new Obj(kind, t.val));.)
                                           {'['int']'}['('int')'].

    //Statements
    StatementList       =   Statement {';' Statement}.
    Statement           =   CallStatement | ForStatement | IfStatement | UnaryStatement | SkipStatement | Signal (SwapStatement | AssignStatement).
    CallStatement       =   ("call"|"uncall") ident     (.Mod calledMod = tab.getModule(t.val);
                                                        if(calledMod == null) {
                                                            Warning("Module "+t.val+"was not defined before this point");
                                                        }
                                                        .)
                            '(' ident                   (.int parCount = 1;.)
                            {',' ident                  (.parCount++;.)
                            } ')'                       (.if(calledMod != null && parCount != calledMod.getParameterCount()) {
                                                            SemErr("Module "+calledMod.name+"needs a different amount of parameters");
                                                        }.)
                            .
    ForStatement        =   "for" [IF(IsIdentEql() || NumberTo()) [IF (IsIdentEql())'$' ident '='] number to] number ["step" ['-'] number] StatementList "rof".
    IfStatement         =   "if" Expression "then" StatementList "else" StatementList "fi" Expression.
    AssignStatement     =   ('^'|'+'|'-') '=' Signal.
    UnaryStatement      =   ('~'|"++"|"--") '=' Signal.
    SwapStatement       =   "<=>" Signal.
    SkipStatement       =   "skip".
    Signal              =   ident                       (.if(!curMod.isDefined(t.val)) {
                                                            SemErr("Signal "+t.val+" is not defined");
                                                          }.)
                            {'[' Expression ']'} ['.' number [':' number]].

    //Expressions
    Expression          =   Signal | IF (IsShift()) ShiftExpression | IF (IsBinary())BinaryExpression | UnaryExpression | number.
    BinaryExpression    =   '(' Expression ('+'|'-'|'^'|'*'|'/'|'%'|"*>"|"&&"|"||"|'&'|'|'|'<'|'>'|'='|"!="|"<="|">=") Expression ')'.
    UnaryExpression     =   ('!'|'~') Expression.
    ShiftExpression     =   '(' Expression (shiftL|shiftR) number ')'.




// End of your compiler specification, make sure the name here matches
// the grammar name at the start of this grammar.
END SyReC.